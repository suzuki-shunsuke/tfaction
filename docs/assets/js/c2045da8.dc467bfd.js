"use strict";(globalThis.webpackChunktfaction=globalThis.webpackChunktfaction||[]).push([[8396],{7710(e,t,a){a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"unreleased/update-pr-branch","title":"Automatic PR Branch Updates","description":"tfaction automatically updates PR branches. There are two types of updates:","source":"@site/docs/unreleased/update-pr-branch.md","sourceDirName":"unreleased","slug":"/unreleased/update-pr-branch","permalink":"/tfaction/docs/unreleased/update-pr-branch","draft":false,"unlisted":false,"editUrl":"https://github.com/suzuki-shunsuke/tfaction-docs/edit/main/docs/unreleased/update-pr-branch.md","tags":[],"version":"current","sidebarPosition":2800,"frontMatter":{"sidebar_position":2800},"sidebar":"tutorialSidebar","previous":{"title":"Skipping terraform plan and apply","permalink":"/tfaction/docs/unreleased/skip-terraform"},"next":{"title":"v2 Release Note","permalink":"/tfaction/docs/unreleased/v2-release-note"}}');var i=a(4848),r=a(8453);const o={sidebar_position:2800},s="Automatic PR Branch Updates",d={},l=[{value:"1. Automatic Update After Apply",id:"1-automatic-update-after-apply",level:2},{value:"2. Automatic Update During PR CI",id:"2-automatic-update-during-pr-ci",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"automatic-pr-branch-updates",children:"Automatic PR Branch Updates"})}),"\n",(0,i.jsx)(t.p,{children:"tfaction automatically updates PR branches. There are two types of updates:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"After running terraform apply on the default branch, PRs that modify the same root module are automatically updated"}),"\n",(0,i.jsx)(t.li,{children:"When CI runs on a PR, the PR branch is automatically updated if it is outdated"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"1-automatic-update-after-apply",children:"1. Automatic Update After Apply"}),"\n",(0,i.jsx)(t.p,{children:"When terraform apply is run for a root module, PRs that modify the same root module need to be updated and have terraform plan run again.\nOtherwise, reviews based on an outdated plan are unreliable, and the plan file in GitHub Artifacts becomes stale, causing apply to fail even if the PR is merged."}),"\n",(0,i.jsxs)(t.p,{children:["tfaction updates these PRs automatically by default, so users do not need any special configuration.\nIf you want to disable automatic updates, you can simply not run the ",(0,i.jsx)(t.code,{children:"update-pr-branch"})," action in your workflow.\nThat said, as mentioned above, updating before merging is necessary, so disabling this is not recommended."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Adding the ",(0,i.jsx)(t.code,{children:"tfaction:disable-auto-update"})," label to a PR prevents that PR from being automatically updated"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"2-automatic-update-during-pr-ci",children:"2. Automatic Update During PR CI"}),"\n",(0,i.jsxs)(t.p,{children:["When CI runs on a PR, the ",(0,i.jsx)(t.code,{children:"setup"})," action compares the feature branch with the base branch and automatically updates the feature branch if it is outdated.\nThe update is triggered when either of the following conditions is met:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Files under the root module have been updated on the base branch"}),"\n",(0,i.jsxs)(t.li,{children:["300 or more files have been updated on the base branch","\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Due to a limitation of GitHub's Compare Two Commits API, diffs can only be retrieved for up to 300 files. If 300 or more files have been updated, there is a possibility that files under the root module have been changed on the base branch"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Unlike type 1, this feature currently cannot be disabled.\nThis is because type 1 has the drawback of unnecessarily updating stale PRs, whereas type 2 only triggers when CI is run on a PR."})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453(e,t,a){a.d(t,{R:()=>o,x:()=>s});var n=a(6540);const i={},r=n.createContext(i);function o(e){const t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);